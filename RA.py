# -*- coding: utf-8 -*-
"""
Created on Sun Feb  2 00:02:44 2020

@author: shi9@llnl.gov
"""

#################################################################
# This script contains functions used to map out 
# the phase diagram in the R-A parameter space
#
####################
# Contents of this script in order of appearence
#
# class Point: a class contains phase info at one point in R-A space
#    member functions:
#        __init__    : initialize member variables
#        __repr__    : print parameters
#        Examining   : determine the nature of this point by Island.xCritical()
#        Classify    : label this point by 4-digit name 
#        Horizon     : compute light horizon radius use Solution.SolveUntil
#         save       : save member varaibles to .txt file
#        Process     : standard procedures of using member functions
#
# readPoint:  : read output file generated by Point and return data as array
# plotPoints  : plot figure for Points
#
# class Phase: a class contains R-A phase diagram info
#    member functions:
#        __init__    : prepare sampling box
#        __repr__    : print parameters
#       precScheme   : For given R, set precision and convergence criteria
#        Analyze     : Compute pflag for given A and iR and save Point to file
#         Extent     : given iR, compute Amax beyond which no transition exists
#         Critical   : Computer critical A for given iR, bisection using Point
#         Diagram    : scan the phase diagram in the R-A space using Critical
#
# ABoundary   : compute critical A across which phase changes, post processing
# AcPoint     : compute Ac boundary by post processing Point files, allow corrections
# readAcPoint : read output .txt dictionary written by AcPoint
# plotAcPoint : plot data generated by AcPoint   
#
# Energy       : post process .txt file from Point and estimate energy of solutions 
# EnergyRefine : re-process .txt file from Energy at higher precision 
# plotEnergy   : plot data generated by Energy
#
#
####################
# Below is a list of artificial parameters. 
# Users are not recommended to adjust these parameters. 
# Global:
#     NB            : maximum number of phases expected 
#                     Physically expect at most 5 phases
#                     Set larger to allow surprises
#                     Control number of columns in output files
#     *invalid      : place-holder values, to keep output file size fixed
# Local to Point:
#     epsilon_bisection_Q
#                   : passed to QP.Island to control convergence criteria
#                     when refining QP phase space boundary/separatrix
#                     See QP.py for more details
#                     if None, use default values in QP.Island
# Local to Phase:
#     epsilon_bisection_A  
#                   : control convergence criteria for dA in Phase.Critical
#                     if too large, phase boundary is too coarse
#                     if too small, ODE convergence poor near boundary, 
#                     in which case smaller step size is needed in SE
#     tflag         : termination phase flag, phase when A->+infty is 0010
#     Extent.Niter  : maximum number of iteractions to search for upper boundary
#
#################################################################
    
import os
        
import SE
import QP
import Auxiliary as AX
import numpy as np
#from netCDF4 import Dataset
import ast # read dictionary
import matplotlib.pyplot as plt
from datetime import datetime
#import sys
#import matplotlib
#from matplotlib import cm
from matplotlib import rc
rc('text', usetex=True)

from decimal import Decimal, getcontext
#getcontext().prec = 28 # default is 28

# default parameters #######################
# maximum number of phases
NB = 10 # physically expect at most 5 phases
# maximum number of island boundaries, used to initialize arrays dimension
NC = 4 # physically expect at most 4 

# place holder for invalid values in Point
# valid should be larger than these 
qinvalid = -999 # integer, compatible with decimal
finvalid = 0
rinvalid = -333

# place holder for values in Phase
Ainvalid = -1

# plot font size
fontsize = 12

#################################################################
# Class contain phase information at each point in the R-A space
#
# Key member variables:
#    ode   : an object of the ODE class, which contains 
#            dim   : dimension of the problem
#            R, A  : coordinate in RA space
#    qlist : a list of 2*NI boundary q values + 1 separatrix value, length 2*NI+1
#            q is the value of the finite-energy solution at tau=0
#    flist : a list of corresponding asymptotic flags, length 2*NI+1
#            f is the asymptotic flag at tau->+infty
#    rlist : a list of light horizon radius, length 2*NI+1
#    pflag : classification of the phase, with the following naming convention
#            (Npp, Nnp, Nnn, Npn) in 4 digit number
#            Npp: number of branches with q>0, f>0
#            Nnp: number of branches with q<0, f>0
#            Nnn: number of branches with q<0, f<0
#            Npn: number of branches with q>0, f<0
#
# Boundary points asymptotics are labeled by +1/-1
# Separatrix points asymptotics are labeled b +6/-6 
#
# When Sample is not specified, the point is exhaustively examined
# in the qp phase space, but the resolution may be insufficient.
# The phase classification is positive in this case.
#
# When Sample is speicfied, the point is examined within the specified
# window in the qp phase space to allow resolving special features. 
# If sample used to zoom in, then some boundary/separatrix point is likely
# omitted. In this case, the phase classification is likely incorect,
# but carried out anyway to ease the program inferface. 
# The phase classification is negative in this case, to indicate use of sample.
#
# Ntmax, epsilon: used for SE.Solution.SolveUntil
# sample        : used for QP.Island.xCritical
# NIm           : expected number of islands. When None, determined automatically

class Point:
    """A class contains phase info at one point in R-A space."""
    
    # initialize 
    def __init__(self,ode,Ntmax=2**24,epsilon=1e-2,sample=None,NIm=None):        
        # load parameters
        self.ode = ode        
        self.Ntmax = Ntmax
        self.epsilon = epsilon
        
        # ensure sample.theta=0, and search along q direction
        if sample!=None: sample.theta = 0
        self.sample = sample
        
        # initialize island
        self.island = QP.Island(ode, Ntmax=Ntmax, epsilon=epsilon, NIm=NIm)
        # intrinsic time step
        self.dt = self.island.dt   
        
        # default number of boundary points
        self.NC = NC
        # defalt arrays. 1: separatrix, NC: bounddary
        self.qlistD = [qinvalid for i in range(NC+1)] # decimal
        self.flist = [finvalid for i in range(NC+1)]
        self.rlist = [rinvalid for i in range(NC+1)] # float
        
        self.pflag = 0
        
    
    # print parameters
    def __repr__(self):
        AX.printf(self.island)
        return 'phase ' + str(self.pflag)
    
        
    # determine the nature of this phase space point
    # by computing cutoff qc for boundary and separatrix
    # sample may be specified for QP.Island.xCritical
    # Input (optinal):
    #    epsilon_bidection_Q : 
    #               convergence criteria for QP.Island.xCritical
    #               if None, use default values when initializing Island
    #    debug    : when true print meta data
    def Examining(self, epsilon_bisection_Q=None, debug=False):
        """Determine the nature of this phase space point."""
        # initialize island
        island = self.island
        # load bisection convergence criteria here to allow user change
        if epsilon_bisection_Q!=None: 
            island.epsilon_bisection = epsilon_bisection_Q           
        # compute critical points, ifplot = False
        xcD, fc, xsD = island.xCritical(sample=self.sample)
        # convert to (q, p)
        qcD, _ = QP.x2qp(xcD, self.sample)
        qsD, _ = QP.x2qp(xsD, self.sample)
        
        # expected number of separatrix
        NS = island.NS
        if debug: 
            #repr(island)
            AX.printf(f'  xRefine depth = {island.depth}')
            AX.printf(f'  flist={island.flist}')
            AX.printf(f'  Cumulative (boundary,separatrix)={(island.bcount,island.scount)}')
            AX.printf(f'  Expected   (boundary,separatrix)={(island.NC,NS)}')
        
        # load separatrix
        ns = len(qsD)
        if ns>NS: AX.printf(f'Expect {NS} separatrix! ns={ns}')
        self.qlistD[:ns] = qsD
        self.flist[:ns] = ns*[self.ode.sflag] # repeat by ns times
        
        # load boundary points
        nc = len(qcD)
        if nc>island.NC: AX.printf(f'Expect {self.NC} boundaries! nc={nc}')
        # load variables, list will be extended if not long enough
        self.qlistD[ns:nc+ns] = qcD
        self.flist[ns:nc+ns] = fc
        
        
    # classify this phase space point
    # by counting the number of finite-energy solutions
    # according to the sign of their initial/final values
    def Classify(self):
        """Classify this phase space point."""
        # unpack
        qlistD = self.qlistD
        flist = self.flist
        # number of island
        nc = self.NC
        
        # default value
        pflag = 0 # no island
        # label each valid island
        for i in range(nc+1):
            qD = qlistD[i]
            f = flist[i]
            if qD!=qinvalid:
                if qD>0 and f>0:
                    pflag += 1000
                elif qD<0 and f>0:
                    pflag += 100
                elif qD<0 and f<0:
                    pflag += 10
                elif qD>0 and f<0:
                    pflag += 1
                    
        # flip sign if sample is specified
        if self.sample!=None:
            pflag = -pflag

        self.pflag = pflag
        
                        
    # compute light horizon
    def Horizon(self):
        """Compute light horizon whenever exist."""
        # unpack
        qlistD = self.qlistD
        flist = self.flist
        
        ode = self.ode
        dt = self.dt
        
        Ntmax = self.Ntmax
        epsilon = self.epsilon
        # number of critical points
        nc = self.NC
        
        # compute for each critical point
        for i in range(nc+1):
            # unpack
            qD = qlistD[i]
            f = int(flist[i]) # ensure integer
            if qD!=qinvalid and qD*f<0: # horizon exist
                # instantiate initial conditions, default p0=0
                cds = SE.Initial(dt=dt, q0D=qD)
                # instantiate solution
                sol = SE.Solution(ode, cds, Ntmax=Ntmax, epsilon=epsilon)
                # solve until horizon is reached, default save='end'
                t, _, _ = sol.SolveUntil(criteria='cross')
                # record value
                self.rlist[i] = t
                
                
    # save all data to file
    def save(self, fname=None):
        """Save var to .txt file."""
        
        # default file name
        if fname==None:
            fname = f'../data/raw/Point{self.ode.dim}D_N{self.Ntmax}_e{self.epsilon}.txt'
            
        # open file, appending
        fid = open(fname, "a+")        
        # write header
        s = f'{self.ode.R}, {self.ode.A}, {self.pflag}'
        
        # unpack dimension
        nc = self.NC
        # unpack arrays
        qlistD, flist, rlist = self.qlistD, self.flist, self.rlist
        
        # prepare content 
        for i in range(nc+1):
            # all digits of decimal will written
            s += f', {qlistD[i]}, {flist[i]}, {rlist[i]}'
        s += '\n'
        
        # write to file
        fid.write(s)
        # close file           
        fid.close() 
        
    # standard procedures of using member functions
    def Process(self, fname=None, epsilon_bisection_Q=None, debug=False):
        """Process point characteristics."""
        self.Examining(epsilon_bisection_Q, debug)
        self.Classify()
        self.Horizon()
        self.save(fname)
        
        return self.pflag
    
    
#################################################################                       
# Read output file generated by Point and return data as array
# Allow to keep decimal precision if desired.
#
# Assume file naming and format conventions as in Point.
# Point data is of the following format:
#    R, A, pflag, (qc, flag, rc), (...), ...
#
# Inputs:
#    iR      : select which file to read
#    fdict   : a dictionary containing dim, Ntmax, epsilon, path
#              file name of Point file is of the form
#              path + f'raw/Point{dim}D_iR{iR}_N{Ntmax}_e{epsilon}.txt'
#  ifdecimal : when False, read as float
#              when true, read as qc as decimal  
#  ifsort    : when true, sort according to A
# Output:
#    lines      : content of the file, numpy array
#                 sorted according to A if desired
def readPoint(iR, fdict, ifdecimal=False, ifsort=True):
    """Read output file generated by Class Point."""
    
    # file name for Point output
    dim=fdict['dim']; Ntmax=fdict['Ntmax']; epsilon=fdict['epsilon']
    fname = fdict['path']+f'raw/Point{dim}D_iR{iR}_N{Ntmax}_e{epsilon}.txt'
    
    # read file
    if os.path.exists(fname): # file exists        
        if ifdecimal: # read qc as decimal
            # initialize list to store file content
            llist = []
            
            # read file 
            fid = open(fname, 'r')
            lines=fid.readlines()
            fid.close()
            
            # process each line
            for line in lines:
                # check if the line is comment='#'
                if line[0] != '#': # not a comment line                   
                    # split line by comma
                    ls = line.split(",")
                    # strip trailing and leading whitespace
                    lss = [s.strip() for s in ls]
                    # dimension
                    nc = int(len(lss)/3)-1 # expected to be integer NC
                    if nc>0: # not an empty line
                        # store data according to desired format
                        # initialize list and store file header
                        lf = [float(lss[0]), float(lss[1]), int(lss[2])]
                        # store (qc, flag, rc)
                        for ii in range(nc):
                            ic = 3*(ii+1)
                            # qc as decimal
                            lf.append(Decimal(lss[ic]))
                            # flag as integer
                            lf.append(int(lss[ic+1]))
                            # rc as float
                            lf.append(float(lss[ic+2]))
                        # store the processed in
                        llist.append(lf)
                    
            # convert to numpy array 
            # in the same orientation as from np.loadtxt 
            lines = np.transpose(np.array(llist))
                        
        else:                 
            # read file as float
            lines = np.loadtxt(fname, comments="#", delimiter=",", unpack=True) 
        
        # sort according to A
        if ifsort: lines = lines[:, lines[1].argsort()]
    else:
        # file not exist
        lines = None
    
    return lines    


#################################################################                       
# Plot saved Point data
# Inputs:
#    iR          : index of R, select which Point file to process
#    fdict       : a dictionary containing dim, Ntmax, epsilon, path
#                  file name of Point file is of the form
#                  path + f'raw/Point{dim}D_iR{iR}_N{Ntmax}_e{epsilon}.txt'
#    varname     : str specify which variables to plot
#                  'full'  : plot qc, rc, pflag, and R
#                  'all'   : plot qc, rc, and pflag
#                  'both'  : plot qc, rc
#                  'qc'    : plot qc
#                  'rc'    : plot rc
#                  'pflag' : plot pflag   
#    dstyle      : dictionary specifying plot style properties    
# Output:
#    R   : source size extracted from the file
def plotPoints(iR, fdict, varname='both', dstyle={}):
    """Read data from .txt file and plot figure for Points."""
    
    # default plot styles if unspecified
    try: c = dstyle['color']
    except KeyError: c='r'
    
    try: ls=dstyle['linestyle']
    except KeyError: ls='--'
    
    try: la=dstyle['label']
    except KeyError: la=''
    
    try: ms=dstyle['markersize']
    except KeyError: ms=4
    
    try: fs=dstyle['fontsize']
    except KeyError: fs=12         
      
    # read file as float, data sorted according to A
    slines = readPoint(iR, fdict)
    # file should exist
    assert(slines.any()!=None) # file does not exist!
                    
    # dimensions
    (ncol, nrow) = slines.shape       
    nc = int(ncol/3)-1
    
    # load values
    x = slines[1] # plot as function of A    
    xmin = x[0]
    xmax = x[len(x)-1]
    title = f'R={slines[0,0]}'   
    
    # indices for f
    indf = [3*(i+1)+1 for i in range(nc)]
    # dictionary for the file content
    Pointdict = {'qc' : {'index': [3*(i+1) for i in range(nc)], 
                         'invalid': qinvalid, 'ylabel': r'$q_c$'},
                 'rc' : {'index': [3*(i+1)+2 for i in range(nc)], 
                         'invalid': rinvalid, 'ylabel': r'$r_c$'}}        
    
    # select variable to plot
    if varname=='qc': vlist = ['qc']
    elif varname=='rc': vlist = ['rc']
    elif varname=='pflag': vlist = ['pflag']
    elif varname=='both': vlist = ['qc', 'rc']
    elif varname=='all': vlist = ['qc','rc','pflag']
    else: vlist = ['qc','rc','pflag','R']
    
    # a list of critical A values at phase boundary
    # if grid: Ac, _, _, _ = ABoundary(x, slines[2], pcorrect=pcorrect)
    # else: Ac = []
        
    # plot figure
    #plt.figure() # for manual refinement, more convenient not to initiate new figure
    NV = len(vlist)
    for iv in range(NV):
        # varname
        var = vlist[iv]        
        # initialize figure
        plt.subplot(1, NV, iv+1)
        # refresh legend label for each variable
        label0 = la
        
        # plot pflag
        if var == 'pflag':
            y = slines[2]
            plt.semilogx(x, y, color=c, marker='.',linestyle=ls,label=label0)           
            plt.ylabel('pflag', fontsize=fs)
        elif var=='R':
            y = slines[0]
            plt.semilogx(x, y, color=c,marker='.',linestyle=ls,label=label0)           
            plt.ylabel('R', fontsize=fs)
        else:      
            # index
            indy = Pointdict[var]['index']
            # invalid value
            invalid = Pointdict[var]['invalid']
            # ylabel
            ylabel = Pointdict[var]['ylabel']            
            
            # read and plot data
            for ii in range(nc):
                # read data
                y = slines[indy[ii]]
                # asymptotic flag
                f = slines[indf[ii]]
            
                # data with f=1                
                xp, yp = AX.fyMask(x, y, f, fmax=0.5, yinvalid=invalid)
                # data with f=-1  
                xn, yn = AX.fyMask(x, y, -f, fmax=0.5, yinvalid=invalid)  
                # data for separatrix f=+6/-6
                xs, ys = AX.fyMask(x, y, abs(f), fmax=4, yinvalid=invalid)
        
                # plot figure 
                plt.semilogx(xp, yp, color=c, linestyle='',
                             marker='+', markersize=ms)
                plt.semilogx(xn, yn, color=c, linestyle='',\
                             marker='o', fillstyle='none',markersize=ms)
                plt.semilogx(xs, ys, color=c, marker='.', linestyle='', label=label0)
                plt.ylabel(ylabel, fontsize=fs)
                # show legend only  once
                label0 = '' 
    
        # mark x axis     
        plt.axhline(y=0, color='grey')
        #plt.legend(loc='best', fontsize=fontsize)           
        # label common x axis
        plt.xlabel('A', fontsize=fs)
        plt.xlim((xmin,xmax))
        # mark phase boundary
        #for ip in range(len(Ac)): plt.axvline(x=Ac[ip], color='grey')
    
    # mark figure
    plt.title(title)
    plt.subplots_adjust(wspace=0.5)
    plt.rcParams.update({'font.size': fs})
    #plt.show()
    
    return slines[0,0]
        
    

#################################################################
# Class contain for phase diagram in the R-A space.
# Default search grid is uniform in logR. 
#
# Due to the symmetry q -> -q, p -> -p, and A -> -A, it is sufficient 
# to consider A>0. Then the minimum A is 0. Practically, take min A = Amin
# When R -> infty, the critical A value asymptotics is roughly
# A/R^n/pi^(n/2) -> 1/3/sqrt(3)~0.19. Hens, the maximum A is < 0.5*R^n*pi^(n/2)
#
# When QP sample is not specified, the program exhaustively search for qp phase
# boundaries and separatrices, but the resolution may be limited. For customized 
# higher resolution searches, one can specify Sample to zoom in special features. 
#
# The phase diagram is computed by examing along R direction. Each iR is 
# written to a file during scan in A direction. The saved data is then post processed.
#
# The default filename for Point is 
#    ../data/{dim}D/batch/raw/Point{dim}D_iR{iR+offset}_N{Ntmax}_e{epsilon}.txt'
#
# Key member variables
#    dim            : dimension of the problem
#    R              : R search array, numpy  array of length NR
#    NA             : number of A points during initial search
#                     Needs not be too large because most interesting 
#                     things happen near boundary, will will be 
#                     automatically added using bisection.
#    logAmin        : log10(Amin), will not search below Amin
#    Ntmax, epsilon : pass to SE.SolveUntil for solving ODE
#    offset         : file name iR offset
#    sample         : when specified, search QP phase space within sample box
#                     if None, search with default setup
#    rath           : string file path for placing output files
#                     if None, place in default folder
#    sdict          : dictionary specifying the R-dependent precision scheme
#                     used for the calculation. See Phase.precScheme
#                     needs to be specified when initialize Phase

class Phase:
    """A class contains R-A phase diagram info."""

    # if print debug message 
    debug = False
    
    # absolute convergence criteria for bisection of critical logA values
    epsilon_bisection_A = 1e-3
    # smaller value requires higher resolution for ODE
    
    # absolute convergence criteria for QP phase space refinement
    epsilon_bisection_Q = None # none means use default balues in QP.Island

    # initialize search array, load dummy values
    # The following default parameters are tested for convergence for R=0.1 to 1000
    # for SolveUntil, which is used by Island and bisection convergence criteria 
    def __init__(self, dim, R, NA=16, logAmin=-2, Ntmax=2*24, epsilon=1e-2, 
                 offset=0, sample=None, rpath=None, sdict=None):
        assert(dim==1 or dim==2 or dim==3)      
        
        # store parameters
        self.dim = dim
        self.R = R  
        self.NA = NA
        self.logAmin = logAmin # log10
        # load resolution for SolveUntil
        self.Ntmax = Ntmax
        self.epsilon = epsilon
        # load file name offset
        self.offset = offset
        # load sample for qp phase space
        self.sample = sample        
        
        # default file tail
        self.ftail = f'_N{Ntmax}_e{epsilon}.txt'        
        # default file path if not specified
        if rpath==None: self.praw = f'../data/{dim}D/batch/raw/'
        else: self.praw = rpath
        AX.printf(f'Raw data will be saved in {self.praw}')
        
        # precision scheme
        # unpack and store sdict if specified
        if sdict!=None:
            if len(sdict)==0: # no scheme is specified
                sdict = None # equivalent to None
            else:                
                Rkeys, Precs = [], []
                for key in sdict:
                    Rkeys.append(float(key))
                    Precs.append(int(sdict[key]))
                # convert to numpy array and sort
                Rkeys, Precs = np.array(Rkeys), np.array(Precs)
                index = Rkeys.argsort()
                self.Rkeys = Rkeys[index]
                self.Precs = Precs[index]
        # store corrected precision scheme
        self.sdict = sdict 
        
        # derived parameters
        NR = len(R)
        self.NR = NR
                 
        # asymptotic A = R^D*pi^(D/2)/3/sqrt(3)
        Rpi = (R*np.sqrt(np.pi))**dim
        # default Amax array determined by asymptotic condicions
        self.Amax = Rpi/3/np.sqrt(3)
  
        # phase termination flag: phase when A->+infty
        if dim==1: self.tflag = [10] # expect 1 negative separatrix
        else: self.tflag = [110, 10] # expect 1 narrow island
        
    # print parameters
    def __repr__(self):
        AX.printf(f'dim={self.dim}, logAmin={self.logAmin}')
        AX.printf(f'Rmin={min(self.R)}, Rmax={max(self.R)}, NR={self.NR}')
        AX.printf(f'Ntmax={self.Ntmax}, epsilon={self.epsilon}')
        AX.printf(f'Bisection in log10A with convergence {self.epsilon_bisection_A}')
        #AX.printf(f'Bisection in Q with convergence {self.epsilon_bisection_Q}')
        #AX.printf(f'Decimal precision is {getcontext().prec}')
        AX.printf(f'Decimal precision scheme is R:prec = {self.sdict}')
        AX.printf(f'Raw data directory: {self.praw}')
        AX.printf(f'sample:\n{self.sample}')
        return ''
    
    
    #################################################################   
    # For given R, set decimal precision and convergence criteria 
    # according to a scheme.
    # Inputs:
    #    R     : source size for ODE, scalar
    #    sdict : dictionary specifying the scheme with the format
    #            sdict={'R1': prec1, 'R2': prec2,...'Rn':precn}
    #            The calculation uses decimal precision prec1 for R<=R1
    #            and precision prec2 for R1<R<=R2, and so on. When R>Rn
    #            use precision precn. If only one entry is specified
    #            then the only prec is used for all R.
    #
    #            epsilon_bisection_Q = 10**(-prec+5) is set s.t.
    #            it fully and safely use the requested decimal precision
    #
    #            When sdict is None, use defaults.
    #            The default for decimal is prec=28
    #            The default for epsilon_bisection_Q is in QP.Island
    #           
    def precScheme(self, R):
        """For given R, set precision and convergence criteria."""
        # After initialization, if sdict is not None, 
        # then Rkeys and Precs are loaded and non empty        
        if self.sdict!=None: # user specified precision scheme
            # unloaded pre-sorted arrays
            Rkeys, Precs = self.Rkeys, self.Precs
            # search for iR s.t. R<Rkeys[iR]
            iR, NR = 0, len(Rkeys) #>=1
            while R>Rkeys[iR]: 
                iR += 1
                if iR==NR: 
                    iR = NR-1
                    break
            # set precision and convergence criteria
            prec = abs(int(Precs[iR])) # ensure positive integer
            getcontext().prec = prec # set globally for decimal
            self.epsilon_bisection_Q = 10**(-prec+5)   
   
    
    #################################################################
    # compute pflag for given A and iR
    def Analyze(self, A, iR):
        """Compute pflag for given A and R and save Point to file."""
        # default file name
        fname = self.praw + f'Point{self.dim}D_iR{iR+self.offset}' + self.ftail
        
        # initialize ode class 
        ode = SE.ODE(self.R[iR], A, self.dim)
        # initialize point class
        point=Point(ode, Ntmax=self.Ntmax, epsilon=self.epsilon,\
                    sample=self.sample)
        # load point info
        pflag = point.Process(fname,self.epsilon_bisection_Q,self.debug)
        
        return pflag
    
    #################################################################
    # Upper bound of Amax beyond which no transition is expected to exist
    def Extent(self, iR):
        """For given R, compute an upper bound of A beyond which no transition exists."""
        ############################
        # maximum number of iteractions to search for upper boundary
        Niter = 100
        # number of times cummulative inside final phase, can be interupted
        Next = 3
        ############################        
        # initial guess
        A = max(1, self.Amax[iR])        
        # asymptotic phase flag
        tflag = self.tflag        
        
        # increase A until reach into final boundary or reach maximum count
        count = 0 # number of times A is doubled
        Nf = 0 # number of times inside the final boundary
        while Nf<Next and count<Niter:
            # update count
            count += 1
            # update A
            A = 2*A
            # compute phase flag
            pflag = self.Analyze(A, iR)
            if pflag in tflag: Nf += 1
            
        # print warining message
        if count>=Niter: 
            AX.printf('warning: Phase.Extent reached maximum number of iterations!')
            
        # update Amax
        self.Amax[iR] = A
        return A
    
    #################################################################
    # computer critical values of A for given iR
    # bisection in logA space, convergence when dlogA < epsilon_bisection_A
    def Critical(self, iR):
        """Computer critical values of A for given iR."""
        # unpack
        debug = self.debug
        NA = self.NA   
        # set precision and convergence criteria
        self.precScheme(self.R[iR])
        if debug: 
            AX.printf(40*'#'+'\n'+f'iR={iR}, R={self.R[iR]}')     
            AX.printf(f'Q bisection criteria is {self.epsilon_bisection_Q}')
            AX.printf(f'Decimal precision is {getcontext().prec}')
                        
        # estimate Amax
        if debug: AX.printf('Searching for Amax')
        Amax = self.Extent(iR)
        if debug: AX.printf(f'Amax = {Amax}')
        
        # construct initial search array, uniform in log10 space
        logAmin = self.logAmin
        logAmax = np.log10(Amax)
        logA = np.linspace(logAmin, logAmax, NA)

        # initial search array
        pflags = []
        if debug: AX.printf('Prepare initial search array')
        for iA in range(NA):
            # update A
            A = 10**logA[iA]
            # compute phase flag
            p = self.Analyze(A, iR)
            # append list
            pflags.append(p)
            if debug: AX.printf(f'iA/NA={iA}/{NA}, A={A}, pflag={p}\n'+10*'#')
            
        # allow new phases to be discovered during refinement
        newAlist = []
        newplist = []
        nnew = 1 # current count of new phases, ensure at least one run
        ncount = 0 # cummulated count of new phases, cap maximum refinements
        if debug: AX.printf('Start refinement')
        while nnew>0:               
            # search transitions
            ind, _ = AX.Jump(pflags, 0.5)    
            # search for critical values with bisection
            n = len(ind) #>=1 if Extent successful
            
            for i in range(n): # search near each transition
                if debug: AX.printf(f'i/n={i}/{n}')
                # initial z left and right boundaries
                zl = logA[ind[i]]
                zr = logA[ind[i]+1]
                
                pl = pflags[ind[i]]
                pr = pflags[ind[i]+1]
                
                # initial difference
                dz = zr - zl
                # assume no new phase for this transition
                nnew = 0 # reset current count
                # bisection
                while dz > self.epsilon_bisection_A:
                    # mid point
                    z = (zl + zr)/2                    
                    # update search value
                    A = 10**z
                    if debug: AX.printf(f'zl={zl}, z={z}, zr={zr}. A={A}')
                    # compute phase flag
                    p = self.Analyze(A, iR)
                    if debug: AX.printf(f'pl={pl}, p={p}, pr={pr}')
                    
                    # update boundaries
                    if p==pr: # move zr left
                        zr = z
                        #AX.printf('move zr left')
                    elif p==pl: # move zl right
                        zl = z
                        #AX.printf('move zl right')
                    else: # new phase
                        nnew += 1 # current count
                        ncount +=1 # cummulated count
                        AX.printf(f'New phase discovered at logA={z} with pflag={p}')
                        # register new phase
                        newAlist.extend([zl, z, zr])
                        newplist.extend([pl, p, pr])
                        # leave current while loop
                        break
                        
                    # update dz
                    dz = zr - zl
                    
                
            # number of new phase discovered in this iteration
            nnew = len(newAlist)
            # consider further refinement if new phases discovered
            if nnew>0:                
                if ncount <= NB: # update search if # new phase less than maximum
                    if debug: AX.printf(f'Refine {int(nnew/3)} new phases. Cummulated count = {ncount}')
                    logA = list(newAlist) # copy list
                    pflags = list(newplist) # copy list
                    newAlist = []
                    newplist = []
                else:
                    if debug: AX.printf(f'Cummulated count = {ncount}')
                    AX.printf('Exceed maximum number of phases. No further refinement.')
                    nnew = 0               
        

    #################################################################
    # Compute the phase diagram in the R-A space
    # Search along R, the computational load is ~ R+1/R 
    # This program can be parallelized using threading
    # search for iR in range(iRmin, iRmax)
    def Diagram(self, iRmin=0, iRmax=None):
        """Compute the phase diagram in the R-A space."""  
        iRmin = int(max(0,iRmin)) # ensure nonnegative integer
        # unpack
        NR = self.NR
        if iRmax==None or iRmax>NR: iRmax = NR
        
        # report info to stdout
        self.__repr__()
        AX.printf(f'Working on iR from {iRmin} to {iRmax} with offset={self.offset}')
        
        # print start time 
        now = datetime.now()
        dt_string = now.strftime("%d/%m/%Y %H:%M:%S")
        AX.printf(f'Compute phase diagram started on {dt_string}')
        
        # process for sach iR
        for iR in range(iRmin, iRmax):
            #AX.printf(f'iR/NR={iR}/{NR}, R={self.R[iR]}')
            # skip R that is set to nan
            if not np.isnan(self.R[iR]):
                # compute critical value
                self.Critical(iR)
            
        # print finish time 
        now = datetime.now()
        dt_string = now.strftime("%d/%m/%Y %H:%M:%S")
        AX.printf(f'Compute phase diagram finished on {dt_string}')

    
#################################################################                       
# Compute A values at the phase boundary for given R
# The program post process Point files, and correct for possible errors.
# Due to finite resolution, narrow islands maybe confused with the separatrix.
# This program correct such errors using a priori knowledge.
#
# Inputs:
#    Alist       : a list of A values, lenth NA
#    plist       : a list of pflag at corresponding A, length NA
#    pcorrect    : a dinctionary of phase corrections,
#                  used when known phases are wrongly identified when
#                  narrow islands are misidentified as separatrix
#                  pcorrect = {'old': new, ...}
# Outout:
#    Ac  : a list of A across which pflag jumps
#    Pc  : a list of phase below the Ac boundary
#    Alist : a list of post-processed A values
#    flag  : a list of post-processed phase flags
#
# Nagative pflag values are excluded, because they correspond to the use of
# sample, in which case the picture is zoomed in and only partial.
def ABoundary(Alist, plist, pcorrect={}, debug=False):
    """Compute critical A across which phase changes."""
    
    # 2D data list
    xy = np.array([Alist, plist])                
    # sort according to A
    data = xy[:, xy[0].argsort()]
    
    # load raw values
    A0 = data[0] # raw A values
    flag0 = data[1] # raw pflag 
    if debug: 
        plt.figure()
        plt.plot(A0,flag0,marker='.',linestyle='')
        
    # remove negative flag values as invalid
    # initialize list
    flag = []
    A = []
    # keep positive flags
    for i in range(len(flag0)):
        f = flag0[i]
        if f>0:
            flag.append(f)
            A.append(A0[i])           
    
    # correct flags
    if len(pcorrect)!=0:
        N = len(flag)
        # replace wrong flag with correct flag
        for i in range(N):
            key = str(int(flag[i])) # expect integer
            #AX.printf(f'i={i}, key={key}')
            if key in pcorrect:
                flag[i] = pcorrect[key]
                if debug: AX.printf(f'i={i}, old flag={key}, new flag={flag[i]}')
                
        # replace dips with nearby larger values
        for i in range(2, N-2):
            # adjacent flags
            #fll = flag[i-2]
            fl = flag[i-1]
            f = flag[i]
            fr = flag[i+1]
            #frr = flag[i+2]
            # check and correct for dip based on nearest neighbor
            if f!=fl and f!=fr:
                flag[i] = max(fl,fr)
            # check and correct for dip based on second nearest neighbor
            #if (fll==fl or frr==fr) and f!=fll and f!=frr:
            #    flag[i] = max(fll,frr)
        
    if debug: plt.plot(A,flag,marker='.',linestyle='')   

    
    # identify index after which jumps occur
    index, _ = AX.Jump(flag, 0.5)
    if debug: AX.printf(index)
    # initialize output
    Ac = []
    Pc = []
    # compute mid points across jumps
    for ind in index:
        # A value before jump
        al = A[ind]
        # A value after jump
        ar = A[ind+1]
        # mid point
        am = (ar + al)/2
        # update by mid point value
        Ac.append(am)
        Pc.append(flag[ind])
        if debug: plt.axvline(x=am, color='grey')  
    if debug: plt.axhline(y=0,color='grey')          
        
    return Ac, Pc, A, flag
 


#################################################################                       
# Compute Ac boundary by post processing Point files
#
# Inputs:
#    iRmin, iRmax: min and max iR index to read file
#    fdict       : a dictionary containing dim, Ntmax, epsilon, path
#                  file name of Point file is of the form
#                  path + f'raw/Point{dim}D_iR{iR}_N{Ntmax}_e{epsilon}.txt'
#    pcorrect    : a dinctionary of phase corrections, for ABoundary
#    ifplot      : if True, plot diagnostic figure
#    ifsave      : if True, save output to txt file 
# Output:
#    Rpdict  : a nested dictionary of RA phase info, which is of the form
#              Rpdict['R'] = {'pflag':Ac, ...}
#              where pflag is the phase flag, Ac is its upper boundary
def AcPoint(iRmin, iRmax, fdict, pcorrect={}, ifplot=False, ifsave=False):
    """Compute Ac from raw output files generated by Point."""   
    
    # initialize output dictionary
    Rpdict = {}        
    # initialize list to keep raw data for contour plot
    if ifplot: Rlist, Alist, plist = [], [], []
    
    for iR in range(iRmin, iRmax):
        # read file as float
        lines = readPoint(iR, fdict)
        # R value
        R = lines[0,0]
                           
        # a list of critical A values at phase boundary
        am, pm, A, flag = ABoundary(lines[1], lines[2], pcorrect=pcorrect)  
        #AX.printf('iR=',iR,' am=',am)
        
        # load phase diationary
        pd = {}
        for ip in range(len(am)):
            key = str(int(pm[ip]))
            pd[key] = am[ip]
        # append to list
        Rpdict[str(R)] = pd

        # keep raw data for contour plot
        if ifplot:
            Rlist.append(len(A)*[R]) # replicate R 
            Alist.append(A)
            plist.append(flag)
            
    # plot figure
    if ifplot:
        # plot phase boundary
        #plt.figure()        
        # flatten countour data
        R = [item for sublist in Rlist for item in sublist]
        A = [item for sublist in Alist for item in sublist]
        p = [item for sublist in plist for item in sublist]        
        # plot contour
        plt.scatter(R, A, c=p, s=10, edgecolors=None, cmap='Set2')  
        #plt.tricontourf(R, A, p, levels=14, linewidths=0.5, cmap='hsv')      
        #plt.tricontour(R, A, p, levels=14, linewidths=0.5, color='k')
        plt.xscale('log')
        plt.yscale('log')
        #plt.show() 
        
    # save dictionary to file
    if ifsave:
        dim=fdict['dim']; Ntmax=fdict['Ntmax']; epsilon=fdict['epsilon'] 
        fid = open(fdict['path']+f'AcPoint{dim}D_N{Ntmax}_e{epsilon}.txt', 'w+')
        fid.write(str(Rpdict))
        fid.close()
        
    return Rpdict
   
    
#################################################################                       
# read Rpdict
def readAcPoint(fname):
    """Read Rpdict from .txt file written by AcPoint."""
    
    # open file for reading
    file = open(fname,'r')
    # read content
    content = file.read()
    # extract dictionary
    Rpdict = ast.literal_eval(content)
    # close file
    file. close()
    
    return Rpdict
    
#################################################################                       
# plot Rpdict
# dstyle: a diactionary of plotting styles
# dstyle = {clist, fontsize, linewidth, markersize}
# clist is a list of colors: clist=[red','blue', ...]
def plotAcPoint(Rpdict, dstyle=None):
    """Plot RA phase diagram as determined by post processing Point files."""
    ###############
    # check dstyle
    if dstyle==None: # use default
        clist = None
        fs = 12
        ms = 8
        lw = 2
        mk = '.'
        ls = '-'
    else: # some are specified
        try: clist = dstyle['clist']
        except KeyError: clist = None
        
        try: fs = dstyle['fontsize']
        except KeyError: fs = 12
        
        try: ms = dstyle['markersize']
        except KeyError: ms = 8
        
        try: lw = dstyle['linewidth']
        except KeyError: lw = 2
        
        try: ls = dstyle['linestyle']
        except KeyError: ls = '-'
        
        try: mk = dstyle['marker']
        except KeyError: mk = '.'
 
    # number of colors
    if clist !=None: nc = len(clist)
        
    ################
    
    # prepare a collection of all phases with their R and A values
    phases = {}    
    # organize R, A according to phases
    for Rkey in Rpdict:
        # extract phase dictionary at this R key
        pd = Rpdict[Rkey]
        # extract phases
        for p in pd:
            # initialize list if not already exist
            if p not in phases:
                phases[p] = {'R':[], 'A':[]}
            # load data
            phases[p]['R'].append(float(Rkey))
            phases[p]['A'].append(pd[p])
            
    # plot each phase
    #plt.figure()
    # color counter
    ic = 0
    for p in phases:
        # prepare data
        data0 = np.array([phases[p]['R'], phases[p]['A']])
        # sort data according to R
        data = data0[:, data0[0].argsort()]
        
        # determine color, default color sequence or user specified
        if clist==None: c = f'C{ic}'
        else: 
            ind = ic % nc
            c = clist[ind]
            
        # plot figure
        plt.loglog(data[0], data[1], linestyle=ls, marker=mk, color=c,
                   linewidth=lw, markersize=ms)
        # add color counter
        ic += 1
        
    # mark axis
    plt.xlabel(r'$R$', fontsize=fs)
    plt.ylabel(r'$A$', fontsize=fs)
    plt.rcParams.update({'font.size': fs})    
    plt.title('Phase diagram')
    

#################################################################     
# Estimate energy of critical solutions by 
# post processing .txt files generated by Point.     
# Use decimal precision in the current context.
#
# This function first refine the phase boundary according to specified
# decimal precision, such that the proxy solution is sufficiently close to
# the critical solution, which asymptotes to +-1 when t->infty.
# This function then integrate the energy density of the proxy
# solution until its |dE| reaches a minimum.
#
# The energy estmates has systematic errors due to 
# (1) the proxy solution not sufficiently close to the critial solution, 
# (2) the integration not including the tail beyond final time, and 
# (3) the integration includes spurious tail of the proxy
# However, assuming the decimal precission is high, the error is small
#
# The targeted final time is tf = 5*max(R,1)
# Presumably proxy SolveUntil>tf  
#
# Inputs:
#    iR      : index of R, select which Point file to process
#    fdict   : a dictionary containing dim, Ntmax, epsilon, path
#              file name of Point file is of the form
#                  path + f'raw/Point{dim}D_iR{iR}_N{Ntmax}_e{epsilon}.txt'
#              post processed data will be saved in 
#                path + f'Energy{dim}D_iR{iR}_d{prec}_N{Ntmax}_e{epsilon}.txt'
#
#    iAmin   : minimum A index to start processing, for restart
#    debug   : print message if True
#    ifflush : if True, close file after each write
#              IO is not the limiting step for high resolution calculations
#
# In the output file, the data is of the format
#    R, A, (q0, E, t, ql, qr, f), (...), ...
#        R      : source size, stored for record and check file overwrite error
#        A      : source amplitude, sorted from small to large
#
#        q0     : initial value qc for the proxy solution
#        E      : energy of the proxy solution upto |dE| reaches minimum
#        t      : termination time for dE integration, when |dE| reaches minimum
#        ql, qr : final bisection boundaries, stored for further refinement
#        f      : asymptotic flag of the solution
#
# The last line of the file is a comment and specifies
#    q0min, q0max, Emin, Emax, tmin, tmax
#
def Energy(iR, fdict, iAmin=0, debug=False, ifflush=False):
    """Post process .txt file from Point and estimate energy of solutions.""" 
    # get decimal precision
    prec = getcontext().prec
    
    # read file with qc as decimal
    # Do not sort by A to allow adding new points to the raw data
    lines = readPoint(iR, fdict, ifdecimal=True, ifsort=False)
    # file should exist
    assert(lines.any()!=None) # file does not exist!
          
    # unpack values in file
    R = lines[0,0]
    # targeted final time
    tf = 5*max(R,1)
    # unpack values in fdict
    dim = fdict['dim']; Ntmax=fdict['Ntmax']; epsilon=fdict['epsilon']
    # output file name
    fname=fdict['path']+f'Energy{dim}D_iR{iR}_d{prec}_N{Ntmax}_e{epsilon}.txt'
    
    # open file, appending
    fid = open(fname, "a+")  
    # write file header
    fid.write('### R, A, (q0, E, t, ql, qr, f), (...), ... ###\n')      
    if ifflush: fid.close() 
    # initialize final comments
    q0min, q0max, Emin, Emax, tmin, tmax = 0, 0, 0, 0, tf, 0
    
    # print start time 
    now = datetime.now()
    dt_string = now.strftime("%d/%m/%Y %H:%M:%S")
    AX.printf(f'Post processing file {fdict}')
    AX.printf(f'R={R}, tf={tf}')
    AX.printf(f'Decimal precision is {prec}')
    AX.printf(f'Scan in A direction started on {dt_string}')
    
    # dimensions
    ncol, NA = lines.shape       
    nc = int(ncol/3)-1 # expected to be integer
    # process each A value
    for iA in range(iAmin, NA):
        # read A
        A = lines[1, iA]
        # write header of string
        s = f'{R}, {A}'

        # print debug message
        if debug: 
            pflag = lines[2, iA]
            AX.printf(10*'#'+f' iA/NA={iA}/{NA}, A={A}, pflag={pflag} '+10*'#') 
            now = datetime.now()
            dt_string = now.strftime("%d/%m/%Y %H:%M:%S")
            AX.printf(f'Current time is {dt_string}')
        
        # initialize ode
        ode = SE.ODE(R, A, dim)
        # instantiate island, by default dt = epsilon*min(1,R) 
        island = QP.Island(ode, Ntmax=Ntmax, epsilon=epsilon)
        # intrinsic resolution 
        dqD0 = Decimal(1/island.Nsample_refine)
        
        # refine each valid q value, decimal
        q0Dlist = []; 
        for iq in range(nc):
            q0D = lines[3*(iq+1), iA]
            # qinvalid is integer, Decimal(invalid) = invalid
            if q0D!= qinvalid: q0Dlist.append(q0D)
        # sort from small to large
        q0Dlist.sort()
        NQ = len(q0Dlist)
        if debug: AX.printf(f'Valid q0 values are: {q0Dlist}\n')
        
        if NQ>=1: # islands identified
            if NQ>1: # island exist, use separation as dq
                # prepare search intervals for bisection
                dqDlist = [q0Dlist[i]-q0Dlist[i-1] for i in range(1,NQ)]
            else: # no island, use resolutionn as dq
                dqDlist = [dqD0]
            
            # pad initial and final
            dqDlist.insert(0, dqDlist[0])
            dqDlist.append(dqDlist[-1])
            # initialize left and right boundaries
            qlDlist, qrDlist = [], []
            fllist, frlist = [], []
            
            for iq in range(NQ):
                # current value
                q0D = q0Dlist[iq]
                
                # step size, keep minimum necessary to accelerate bisection
                dqD = min(dqDlist[iq], dqDlist[iq+1], dqD0)/2
                # initialize left and right flag
                qlD, qrD = q0D-dqD, q0D+dqD               
                
                # extend interval to contain transition
                qlD,qrD,fl,fr=island.xInterval(qlD,qrD,dqD,debug=debug)                
                # load boundary points
                qlDlist.append(qlD); qrDlist.append(qrD) 
                fllist.append(fl); frlist.append(fr)
                
 
        if debug: 
            AX.printf(f'Bisection \nq left={qlDlist}\n \nq right={qrDlist}')
            AX.printf(f'Bisection \nf left={fllist}, f right={frlist}')
        
        
        # refine each q with bisection
        ec = 0 # error counter, expected to be zero
        for iq in range(NQ): # if NQ=0, the following block will not be run
            # read flag from original file
            flag = lines[3*(iq+1)+1, iA]            
            # print debug message
            if debug: 
                q0 = float(q0Dlist[iq])
                AX.printf(3*'#'+f' iq/NQ={iq}/{NQ}, q0={q0}, flag={flag} '+3*'#')   
            
            # find q0 using bisection, return none if error
            qlD, qrD = qlDlist[iq], qrDlist[iq]
            fl, fr = fllist[iq], frlist[iq]
            q0D,_,qlD,qrD=island.xBisect(qlD,qrD,tf,fl=fl,fr=fr,side=iq,debug=debug)
            
            if q0D !=None: # transition exist                   
                # specify initial conditions 
                cds = SE.Initial(dt=island.dt, q0D=q0D)  
                # instantiate the solution
                sol = SE.Solution(ode, cds, Ntmax=Ntmax, epsilon=epsilon)
    
                # estimate energy of solution using Terms, which uses SolveUntil
                dterms = sol.Terms(ifplot=False)
                # final time of the dE integration, when |dE| reaches minimum
                t = dterms['t'][dterms['it']]
                # estimated energy of the solution, integrate dE upto t
                E = dterms['E'][dterms['it']]
                
                # prepare string to write in format (q0, E, t, ql, qr, f)
                # all digits of decimal will written            
                s += f', {q0D}, {E}, {t}, {qlD}, {qrD}, {flag}'
                if debug: AX.printf(f'Energy estimate it= {dterms["it"]}, t={t}')
                
                # update bounds
                q0 = float(q0D)
                q0min, q0max = min(q0min, q0), max(q0max, q0)
                Emin, Emax = min(Emin, E), max(Emax, E)
                tmin, tmax = min(tmin, t), max(tmax, t)
            else:
                ec += 1
                AX.printf(f'!!!! Warning: no transition found for iq={iq} !!!') 
            
        # write place holders to make file the same size
        for iq in range(NQ-ec,nc):
            s += f',{qinvalid},{0},{0},{qinvalid},{qinvalid},{finvalid}'
            
        # new line
        s += '\n'        
        # write to file
        if ifflush: fid = open(fname, "a+")  
        fid.write(s)
        if ifflush: fid.close() 
        
    # write bounds as comment on last line
    if ifflush: fid = open(fname, "a+")  
    fid.write('# q0min, q0max, Emin, Emax, tmin, tmax\n')
    fid.write(f'# {q0min}, {q0max}, {Emin}, {Emax}, {tmin}, {tmax}\n')
    # close file           
    fid.close() 
    
    # print end time 
    now = datetime.now()
    dt_string = now.strftime("%d/%m/%Y %H:%M:%S")
    AX.printf(f'Scan in A direction finished on {dt_string}')


#################################################################   
# Re-process .txt file from Energy for higher precision   
#
# Inputs:
#    iR      : index of R, select which Point file to process
#    prec0   : decimal precision used in previous run
#    fdict   : a dictionary containing dim, Ntmax, epsilon, path
#              file name of Point file is of the form
#                  path + f'raw/Point{dim}D_iR{iR}_N{Ntmax}_e{epsilon}.txt'
#              post processed data will be saved in 
#                path + f'Energy{dim}D_iR{iR}_d{prec}_N{Ntmax}_e{epsilon}.txt'
#
#    tfmin   : if tfinal<tfmin, reprocess the data
#              tfinal is the time energy integration is terminated
#              the solution itsself usually terminate at a later time
#    dprec   : increase of precision for this run
#    debug   : print message if True
#    ifflush : if True, close file after each write
#              IO is not the limiting step for high resolution calculations
def EnergyRefine(iR, prec0, fdict, tfmin, dprec=25, debug=False, ifflush=False):
    """Re-process .txt file from Energy at higher precision.""" 
    # set decimal precision
    prec1 = prec0 + dprec
    getcontext().prec = prec1 
    
    # old file name for Energy output
    dim=fdict['dim']; Ntmax=fdict['Ntmax']; epsilon=fdict['epsilon']
    fold=fdict['path']+f'Energy{dim}D_iR{iR}_d{prec0}_N{Ntmax}_e{epsilon}.txt'
    # check file exist
    assert(os.path.exists(fold))
 
    # read previous file 
    fid = open(fold, 'r')
    lines=fid.readlines()
    fid.close()
    
    # new file name
    fnew=fdict['path']+f'Energy{dim}D_iR{iR}_d{prec1}_N{Ntmax}_e{epsilon}.txt'    
    # open file, replace
    fid = open(fnew, "w+")  
    # write file header
    fid.write(f'# Reprocessing {fold} with precision={prec1}, tfmin={tfmin}\n')
    fid.write('### R, A, (q0, E, t, ql, qr, f), (...), ... ###\n')      
    if ifflush: fid.close() 
    # final time of solution 
    tf = 2*tfmin
    
    # print start time 
    now = datetime.now()
    dt_string = now.strftime("%d/%m/%Y %H:%M:%S")
    AX.printf(f'Post processing file {fdict}')
    AX.printf(f'Old precision is {prec0}. New precision is {prec1}')
    AX.printf(f'Refinement started on {dt_string}')
    
    
    NL = len(lines) # total number of lines
    il = 0 # line counter
    # process each line
    for line in lines:
        if debug: AX.printf(f'Processing line {il}/{NL}')
        il += 1
        # check if the line is comment='#'
        if line[0] != '#': # not a comment line                   
            # split line by comma
            ls = line.split(",")
            # strip trailing and leading whitespace
            lss = [s.strip() for s in ls]
            #print(lss)
            # dimension
            nc = int((len(lss)-2)/6) # expected to be integer NC
            
            # extract index where tfinal<tfmin and q is valid
            index = []
            for i in range(nc):
                try: q0 = int(float(lss[2+i*6]))
                except ValueError: q0=qinvalid
                
                try: tfinal = float(lss[4+i*6]) 
                except ValueError: tfinal=0
                
                if q0!=qinvalid and tfinal<tfmin:
                    index.append(i)
                    
            # number of points to be refined
            nr = len(index)
            if nr>0: # refinement needed
                # extract R and A values
                R = float(lss[0])
                A = float(lss[1])
                
                # initialize ode
                ode = SE.ODE(R, A, dim)
                # instantiate island, by default dt = epsilon*min(1,R) 
                island = QP.Island(ode, Ntmax=Ntmax, epsilon=epsilon)
                
                # print debug message
                if debug: 
                    AX.printf(10*'#'+f' A={A} '+10*'#') 
                    now = datetime.now()
                    dt_string = now.strftime("%d/%m/%Y %H:%M:%S")
                    AX.printf(f'Current time is {dt_string}')
                    
                # refine each point
                for i in index:
                    # baseline index
                    ic = 6*i+5
                    # original left and right bounds of bisection
                    qlD = Decimal(lss[ic])
                    qrD = Decimal(lss[ic+1])
                    if debug: 
                        AX.printf(3*'#'+f'i/N={i}/{nr} '+3*'#')
                        AX.printf(f'Original flag={lss[ic+2]}, tfinal={lss[ic-1]}')
                    
                    # extend interval to contain transition
                    dxD = 10**(-prec0+3) # precision of previous run
                    qlD,qrD,fl,fr=island.xInterval(qlD,qrD,dxD,debug=debug)                
                    #print(qlD, qrD)
                    # use bisection to find q0
                    q0D,_,qlD,qrD = island.xBisect(qlD,qrD,tf,fl=fl,fr=fr,side=i,debug=debug)
            
                    # if no transition found, write original data
                    # otherwise, update with new values
                    if q0D !=None: # transition exist                   
                        # specify initial conditions 
                        cds = SE.Initial(dt=island.dt, q0D=q0D)  
                        # instantiate the solution
                        sol = SE.Solution(ode, cds, Ntmax=Ntmax, epsilon=epsilon)
            
                        # estimate energy of solution using Terms, which uses SolveUntil
                        dterms = sol.Terms(ifplot=False)
                        # final time of the dE integration, when |dE| reaches minimum
                        t = dterms['t'][dterms['it']]
                        # estimated energy of the solution, integrate dE upto t
                        E = dterms['E'][dterms['it']]
                        if debug: AX.printf(f'New tfinal={t}')
                        
                        # update the lss
                        lss[ic], lss[ic+1] = str(qlD), str(qrD)
                        lss[ic-3] = str(q0D)
                        lss[ic-1], lss[ic-2] = str(t), str(E)   

            # join string, separated by comma, add end of line symbol
            line = ", ".join(lss) + '\n'
            # write line to new file
            if ifflush: fid = open(fnew, "a+")  # append
            fid.write(line)
            if ifflush: fid.close() 
 
    # close file           
    fid.close()     
    # print end time 
    now = datetime.now()
    dt_string = now.strftime("%d/%m/%Y %H:%M:%S")
    AX.printf(f'Scan in A direction finished on {dt_string}')


#################################################################    
# plot data generated by Energy
# The format of the data file is 
#    R, A, (q0, E, t, ql, qr, f), (...), ...
#
# Inputs:
#    fname  : name of data file generated by Energy
#    tfRmin : minimum tf in unit of R
#             data with t<R*tfRmin are definitely wrong and will be omitted
#    ifdiag : when False, only plot E
#             when True, also plot t, where t is the final integration time 
def plotEnergy(fname, tfRmin=1, ifdiag=True):
    """Plot data generated by Energy."""
    ###################
    # markersize
    ms = 24
    # default map from value to color
    cm = plt.cm.get_cmap('cool')
    ###################
    
    # report file name
    print('file name is', fname)
    # extract digits from path, which should contain dim
    digits = ''.join(filter(lambda i: i.isdigit(), fname))
    # dim in str format
    try: sdim = digits[0]
    except IndexError: sdim='' # if dim is not contained in fpath
    
    # read file as float
    lines = np.loadtxt(fname, comments="#", delimiter=",", unpack=True) 
    
    # dimensions
    (ncol, NA) = lines.shape       
    nc = int((ncol-2)/6) # expected to be integer
    
    # R value
    R = lines[0,0]
    tfmin = R*tfRmin
    # figure title
    title=f'dim={sdim}, R={R}'    
    
    # read bounds from last line comment if exist
    with open(fname, 'r') as fid: ll = fid.readlines()[-1]        
    # check last line is a comment start with '#'
    if ll[0]=='#':
        # split by comma
        ls = ll.split(",")
        # remove leading comment
        ls[0]=ls[0][1:]
        # remove space and newline symbols, convert to float
        # bounds=[q0min, q0max, Emin, Emax, tmin, tmax]
        bounds = [float(s.strip()) for s in ls]
        # q bounds
        qmin, qmax = bounds[0], bounds[1]
    else:
        # determin qmin and qmax from data
        qmin, qmax = 0, 0
        for i in range(nc):
            # read q line
            q = lines[6*i+2]
            # mask invalid value
            qm = np.ma.masked_where(q==qinvalid,q)
            # if there are valid values
            nv = np.ma.MaskedArray.count(qm)
            if nv>0:
                ql = np.ma.MaskedArray.min(qm)
                qr = np.ma.MaskedArray.max(qm)
                qmin, qmax = min(ql, qmin), max(qr, qmax)           
        

    # plot as function of A, with color coded by q0, marker by flag
    # store data for flag=1 and -1 separately [[flag=-1], [flag=1]]
    Alist, Elist, tlist, qlist = [[],[]], [[],[]], [[],[]], [[],[]]
    for iA in range(NA):
        # read A
        A = lines[1, iA]
        for ii in range(nc):
            iq = ii*6+2
            # read qc
            q0 = lines[iq, iA]
            # read tfinal
            t = lines[iq+2, iA]
            # store data if valid
            if q0 != qinvalid and t>tfmin:
                # energy and asymptotic flag
                E, f = lines[iq+1, iA], lines[iq+5, iA]
                # index to store data
                ind = int(np.heaviside(f, 0))
                # load data
                Alist[ind].append(A); qlist[ind].append(q0);
                Elist[ind].append(E); tlist[ind].append(t);
 
                    
    # data to plot
    data = [tlist, Elist] # plot E last to overlay of asymptotic results
    ylabels = ['t final', 'Energy']
    if ifdiag: nd=0
    else: nd=1        
                    
    # plot E and t
    for ii in range(nd,2):
        #plt.figure()   
        plt.figure(num=None, figsize=(3, 4)) 
        # plot flag=1 with "+" marker
        sc = plt.scatter(Alist[1],data[ii][1],c=qlist[1],s=ms,marker='+',\
                         vmin=qmin, vmax=qmax, cmap=cm)
        # plot flag=-1 with "o" marker
        sc = plt.scatter(Alist[0],data[ii][0],c=qlist[0],s=ms,marker='o',\
                         vmin=qmin, vmax=qmax, cmap=cm)  
        sc.set_facecolor('none')
        
        plt.xscale("log")
        plt.xlabel(r'$A$')
        plt.ylabel(ylabels[ii])
        plt.title(title)
        plt.axhline(y=0, color='grey')
        
        cbar=plt.colorbar(sc)
        cbar.ax.set_ylabel(r'$q_c$',rotation=0,labelpad=10)
    
    return Alist, qlist, data
    
    
    
    
                
    

